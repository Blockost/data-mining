/**
 * Méthode principale du projet
 * Initialise les principales variables, créer le jeu de données et itère une première fois
 * @returns {[]} Retourne les données à afficher sur le canvas 2D
 */
var main = function(){

    /*
      Jeu de test de base : [[1, 2], [4, 5], [7, 8], [1, 5], [5, 9], [6, 7], [5, 5], [8, 8]]
     */

    var number_of_data = 60;
    var data = generateData(number_of_data).map(function(element) {
        return [element[0] * 50, element[1] * 20, element[2]];
    });

    // Nombre de classes
    var number_of_classes = 4;

    var barycenters = k_means_algorithm(data, number_of_classes);

    // Retourne les données à afficher sur le canvas 2D
    return [data, number_of_classes, barycenters];
}

/**
 * Fonction permettant d'exécuter une première fois l'algo des k-means
 * @param data le jeu de données
 * @param number_of_classes le nombre de classes
 * @returns {[]} Un tableau de dimmension @param number_of_classes contenant le centre de chaque classse
 */
function k_means_algorithm(data, number_of_classes){
    var classes = [];
    var center_of_classes = [];
    var distance_array = [];
    var min_index = [];

    /*

    Etape 1 : Choisir k individus au hasard comme
    centres initiaux des classes.

    */

    determineCenterOfClassesRandomly(data, center_of_classes, number_of_classes);


    /*

    Etape 2 : On calcule les distances entre chaque
    individu et chaque centre de classe, et on
    affecte l’individu à la classe la plus proche.

      */

    data.forEach(function(element, index){
        distance_array[index] = getDistanceWithAllCenters(center_of_classes, element);
    });


    distance_array.forEach(function(element, index){
        min_index[index] = getMinIndex(element);
    });

    /*

    Etape 3 : On remplace les centres des classes
    par les k centres de gravité des classes définies
    à l’étape 2.

    */


    return forAll_getBarycenter(min_index, number_of_classes, data);

    /*

    Etape 4 : On itère à partir de l’étape 2 jusqu’à
    convergence.

        ==> iterate FUNCTION
    */
}

exports.main = main;


/**
 * Fonction permettant de générer un jeu de données aléatoires sans cluster (aucune séparation entre les points)
 * @param number_of_data
 * @returns {Array} tableau contenant les points (Vecteur 2D) du jeu de données
 */
function generateData(number_of_data){
    var data = [];
    for(var i = 0; i < number_of_data; i++){
        data[i] = [Math.floor(Math.random()*10), Math.floor(Math.random()*20)];
    }
    return data;
}

/**
 * Fonction permettant de définir aléatoirement les centres de classes lors de la 1ère itération
 * @param data le jeu de données
 * @param center_of_classes tableau contenant le centre des classes
 * @param number_of_classes le nombre de classes souhaitées
 */
function determineCenterOfClassesRandomly(data, center_of_classes, number_of_classes){
    var index = 0;
    var last = [];
    for(var i = 0; i < number_of_classes; i++){
        do{
            index = Math.floor(Math.random() * data.length);
        }while(last.indexOf(index) >= 0);
        last.push(index);
        center_of_classes[i] = data[index];
    }
}

/**
 * Fonction permettant d'obtenir la distance entre un point et tous les centres de classes
 * @param center_of_classes tableau contenant le centre des classes
 * @param point le point de référence
 * @returns {Array} tableau contenant la distance entre le point de référence @param point et les centres de classes @param center_of_classes
 */
function getDistanceWithAllCenters(center_of_classes, point){
    var distance = [];
    center_of_classes.forEach(function(element){
        distance.push(getDistance(element, point));
    });
    return distance
}

/**
 * Fonction permettant de déterminer la distance euclidienne entre 2 vecteurs
 * @param v1 vecteur n°1 de taille n
 * @param v2 vecteur n°2 de taille n
 * @returns {number} le distance euclidienne entre ces deux vecteurs
 */
function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        // Index = 22 => c'est la classe du point et non ses coordonnées
        if(index != 2){
            distance += Math.pow((element - v2[index]), 2);
        }
    });
    return Math.sqrt(distance);
}

/**
 * Fonction permettant de récupérer le minimun d'un tableau
 * @param vector tableau référence
 * @returns {number} le minimum du tableau @param vector
 */
function getMinIndex(vector){
    return vector.indexOf(Math.min.apply(null, vector));
}

/**
 * Fonction permettant de calculer les coordonnées du barycentre d'un ensemble de points
 * @param class_vector tableau contenant les points appartenant à une même classe
 * @returns {[]} tableau de taille 2 (un point) contenant les coordonnées du barycentre
 */
function getBarycenter(class_vector){
    var sum_x = 0;
    var sum_y = 0;
    class_vector.forEach(function(element, index){
        sum_x += element[0];
        sum_y += element[1];
    })
    return [sum_x/class_vector.length, sum_y/class_vector.length];
}

/**
 * Fonction permettant d'effectuer la recherche de barycentres sur l'ensemble des points
 * @param min_index tableau contenant la classe la plus proche pour chaque point
 * @param number_of_classes le nombre de classses
 * @param data le jeu de données
 * @returns {Array} un tableau contenant les coordonnées de l'ensemble des barycentres trouvés
 */
function forAll_getBarycenter(min_index, number_of_classes, data){
    var tmp_classes = [];
    var barycenters = [];
    for (var i = 0; i < number_of_classes; i++) {
        tmp_classes = [];
        min_index.forEach(function(element, index){
            if (element == i) {
                // On ajoute la classe du point au point :)
                data[index][2] = i;
                tmp_classes.push(data[index]);
            }
        });
        barycenters.push(getBarycenter(tmp_classes));
    }
    return barycenters;
}

/**
 * Fonction permettant d'exécuter l'algo sur le jeu de données @param data (déjà init, voir la méthode 'k_means_algorithm')
 * Le principe de cette fonction est quasi identique à celui de la fonction 'main'.
 * @param data le jeu de données
 * @param number_of_classes le nombre de classes
 * @param barycenters l'ensemble des barycentres
 * @returns {[]} les données à afficher sur le canvas 2D
 */
var iterate = function(data, number_of_classes, barycenters){
    var distance_array = [];
    var min_index = [];
    data.forEach(function(element, index){
        if(index != 2){
            distance_array[index] = getDistanceWithAllCenters(barycenters, element);
        }
    });
    distance_array.forEach(function(element, index){
        min_index[index] = getMinIndex(element);
    });
    barycenters = forAll_getBarycenter(min_index, number_of_classes, data);
    return [data, number_of_classes, barycenters];
};

exports.iterate = iterate;