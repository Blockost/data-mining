/*
    Global variable
 */

var x_coeff, y_coeff;
/**
 * Méthode principale du projet
 * Initialise les principales variables, créer le jeu de données et itère une première fois
 * @param data_read détient, s'il y a eu lieu, les data du jeu de données lu
 * @returns {[]} Retourne les données à afficher sur le canvas 2D
 */
var main = function(data_read){

    /*
        Jeu de test de base : [[1, 2], [4, 5], [7, 8], [1, 5], [5, 9], [6, 7], [5, 5], [8, 8]]
     */

    var data = [];

    var number_of_data = 500;

    // Si aucun jeu de données n'a été précisé...
    if(typeof data_read === 'undefined'){
        x_coeff = 118;
        y_coeff = 37
        data = generateData(number_of_data).map(function(element){
            return [element[0] * x_coeff, element[1] * y_coeff, element[2]];
        });

    // Sinon...
    }else{
        // Traitement d'affichage différent pour optimiser la position des points sur le canvas
        if(data_read.filename == "Test-Clusters-Distincts.txt"){
            x_coeff = 60;
            y_coeff = 25;
            data = data_read.data.map(function(element){
                return [(element[0]+10) * x_coeff, (element[1]+20) * y_coeff, element[2]];
            });
        }else{
            x_coeff = 125;
            y_coeff = 60;
            data = data_read.data.map(function(element){
                return [(element[0]+5) * x_coeff, (element[1]+5) * y_coeff, element[2]];
            });
        }


    }

    // Nombre de classes
    var number_of_classes = 4;

    var barycenters = k_means_algorithm(data, number_of_classes);

    // Retourne les données à afficher sur le canvas 2D
    return [data, number_of_classes, barycenters, "\"Not yet\"", "\"Not yet\""];
}

/**
 * Fonction permettant d'exécuter une première fois l'algo des k-means
 * @param data le jeu de données
 * @param number_of_classes le nombre de classes
 * @returns {[]} Un tableau de dimmension @param number_of_classes contenant le centre de chaque classse
 */
function k_means_algorithm(data, number_of_classes){
    var classes = [];
    var center_of_classes = [];
    var distance_array = [];
    var min_index = [];

    /*

    Etape 1 : Choisir k individus au hasard comme
    centres initiaux des classes.

    */

    determineCenterOfClassesRandomly(data, center_of_classes, number_of_classes);


    /*

    Etape 2 : On calcule les distances entre chaque
    individu et chaque centre de classe, et on
    affecte l’individu à la classe la plus proche.

      */

    data.forEach(function(element, index){
        distance_array[index] = getDistanceWithAllCenters(center_of_classes, element);
    });


    distance_array.forEach(function(element, index){
        min_index[index] = getMinIndex(element);
    });

    /*

    Etape 3 : On remplace les centres des classes
    par les k centres de gravité des classes définies
    à l’étape 2.

    */


    return forAll_getBarycenter(min_index, number_of_classes, data);

    /*

    Etape 4 : On itère à partir de l’étape 2 jusqu’à
    convergence.

        ==> iterate FUNCTION
    */
}

exports.main = main;


/**
 * Fonction permettant de générer un jeu de données aléatoires sans cluster (aucune séparation entre les points)
 * @param number_of_data
 * @returns {Array} tableau contenant les points (Vecteur 2D) du jeu de données
 */
function generateData(number_of_data){
    var data = [];
    for(var i = 0; i < number_of_data; i++){
        data[i] = [Math.random()*10, Math.random()*20];
    }
    return data;
}

/**
 * Fonction permettant de définir aléatoirement les centres de classes lors de la 1ère itération
 * @param data le jeu de données
 * @param center_of_classes tableau contenant le centre des classes
 * @param number_of_classes le nombre de classes souhaitées
 */
function determineCenterOfClassesRandomly(data, center_of_classes, number_of_classes){
    var index = 0;
    var last = [];
    for(var i = 0; i < number_of_classes; i++){
        do{
            index = Math.floor(Math.random() * data.length);
        }while(last.indexOf(index) >= 0);
        last.push(index);
        center_of_classes[i] = data[index];
    }
}

/**
 * Fonction permettant d'obtenir la distance entre un point et tous les centres de classes
 * @param center_of_classes tableau contenant le centre des classes
 * @param point le point de référence
 * @returns {Array} tableau contenant la distance entre le point de référence @param point et les centres de classes @param center_of_classes
 */
function getDistanceWithAllCenters(center_of_classes, point){
    var distance = [];
    center_of_classes.forEach(function(element){
        distance.push(getDistance(element, point));
    });
    return distance
}

/**
 * Fonction permettant de déterminer la distance euclidienne entre 2 vecteurs
 * @param v1 vecteur n°1 de taille n
 * @param v2 vecteur n°2 de taille n
 * @returns {number} le distance euclidienne entre ces deux vecteurs
 */
function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        console.log(x_coeff);
        switch (index){
            case 0:
                distance += Math.pow((element/x_coeff - v2[index]/x_coeff), 2);
                break;
            case 1:
                distance += Math.pow((element/y_coeff - v2[index]/y_coeff), 2);
                break;
            default:
                // Index = 2 => c'est la classe du point et non ses coordonnées
                break;
        }
    });
    return Math.sqrt(distance);
}

/**
 * Fonction permettant de récupérer le minimun d'un tableau
 * @param vector tableau référence
 * @returns {number} le minimum du tableau @param vector
 */
function getMinIndex(vector){
    return vector.indexOf(Math.min.apply(null, vector));
}

/**
 * Fonction permettant de calculer les coordonnées du barycentre d'un ensemble de points
 * @param class_vector tableau contenant les points appartenant à une même classe
 * @returns {[]} tableau de taille 2 (un point) contenant les coordonnées du barycentre
 */
function getBarycenter(class_vector){
    var sum_x = 0;
    var sum_y = 0;
    class_vector.forEach(function(element, index){
        sum_x += element[0];
        sum_y += element[1];
    })
    return [sum_x/class_vector.length, sum_y/class_vector.length];
}

/**
 * Fonction permettant d'effectuer la recherche de barycentres sur l'ensemble des points
 * @param min_index tableau contenant la classe la plus proche pour chaque point
 * @param number_of_classes le nombre de classses
 * @param data le jeu de données
 * @returns {Array} un tableau contenant les coordonnées de l'ensemble des barycentres trouvés
 */
function forAll_getBarycenter(min_index, number_of_classes, data){
    var tmp_classes = [];
    var barycenters = [];
    for (var i = 0; i < number_of_classes; i++) {
        tmp_classes = [];
        min_index.forEach(function(element, index){
            if (element == i) {
                // On ajoute la classe du point au point :)
                data[index][2] = i;
                tmp_classes.push(data[index]);
            }
        });
        barycenters.push(getBarycenter(tmp_classes));
    }
    return barycenters;
}

/**
 * Fonction permettant d'exécuter l'algo sur le jeu de données @param data (déjà init, voir la méthode 'k_means_algorithm')
 * Le principe de cette fonction est quasi identique à celui de la fonction 'main'.
 * @param data le jeu de données
 * @param number_of_classes le nombre de classes
 * @param barycenters l'ensemble des barycentres
 * @returns {[]} les données à afficher sur le canvas 2D
 */
var iterate = function(data, number_of_classes, barycenters){
    var distance_array = [];
    var min_index = [];
    data.forEach(function(element, index){
        if(index != 2){
            distance_array[index] = getDistanceWithAllCenters(barycenters, element);
        }
    });
    distance_array.forEach(function(element, index){
        min_index[index] = getMinIndex(element);
    });

    barycenters = forAll_getBarycenter(min_index, number_of_classes, data);

    var barycenter_of_canvas = getBarycenter(data);
    var inertie_totale = getInertie(data, barycenter_of_canvas);
    var inertie_inter_classes = getInertieInterClasses(data, barycenters, barycenter_of_canvas, min_index);
    var inertie_intra_classes = getInertieIntraClasses();

    return [data, number_of_classes, barycenters, inertie_inter_classes / inertie_totale, inertie_intra_classes];
};

exports.iterate = iterate;

function getInertie(vector, barycenter){
    var inertie = 0;
    vector.forEach(function(element){
        inertie += Math.pow(getDistance(element, barycenter),2) / vector.length;
    });
    return inertie;
}

function getInertieInterClasses(data, barycenters, barycenter_of_canvas, min_index){
    var inertie = 0;
    //Inertie inter classes
    barycenters.forEach(function(element, index){
        inertie += countDuplicate(min_index, index)/data.length * Math.pow(getDistance(element, barycenter_of_canvas), 2);
    });
    return inertie;
}

function getInertieIntraClasses(){
    return 0;
}

/**
 * Fonction permettant de compter le nombre de doublons dans un vecteur
 * @param vector le vecteur
 * @param n le nombre à compter
 * @returns {number} le nombre
 */
function countDuplicate(vector, n){
    var count = 0;
    vector.forEach(function(element){
        if(element == n) count++;
    });
    return count;
}