var main = function(){

    var data = [[1, 2], [4, 5], [7, 8], [1, 5], [5, 9], [6, 7], [5, 5], [8, 8]].map(function(element) {
        return [element[0] * 50, element[1] * 20];
    });
    var number_of_classes = 2;
    var barycenters = k_means_algorithm(data, number_of_classes);
    return [data, barycenters];

}

function k_means_algorithm(data, number_of_classes){
    var classes = [];
    var center_of_classes = [];
    var distance_array = [];
    var min_index = [];
    var barycenters = [];

    console.log("\ndata : ");
    console.log(data);

    /*

    Etape 1 : Choisir k individus au hasard comme
    centres initiaux des classes.

    */

    for(var i = 0; i < number_of_classes; i++){
        center_of_classes[i] = data[Math.floor(Math.random()*data.length)];
    }

    console.log("\ncenter of classes : ");
    console.log(center_of_classes);

    /*

    Etape 2 : On calcule les distances entre chaque
    individu et chaque centre de classe, et on
    affecte l’individu à la classe la plus proche.

      */

    data.forEach(function(element, index){
        distance_array[index] = getDistanceWithAllCenters(center_of_classes, element);
    });

    console.log("\ndistance array : ");
    console.log(distance_array);

    distance_array.forEach(function(element, index){
        min_index[index] = getMinIndex(element);
    });
    console.log("\ngetMinIndex : ");
    console.log(min_index);

    /*

    Etape 3 : On remplace les centres des classes
    par les k centres de gravité des classes définies
    à l’étape 2.

    */

    barycenters = forAll_getBarycenter(min_index, number_of_classes, data);

    console.log("\nforAll_getBarycenter :");
    console.log(barycenters);

    return barycenters;

    /*

    Etape 4 : On itère à partir de l’étape 2 jusqu’à
    convergence.

    */

    for (var i = 0; i < 5; i++) {
        data.forEach(function(element, index){
            distance_array[index] = getDistanceWithAllCenters(barycenters, element);
        });
        distance_array.forEach(function(element, index){
            min_index[index] = getMinIndex(element);
        });
        barycenters = forAll_getBarycenter(min_index, number_of_classes, data);
    }

}

exports.main = main;

/**
 *
 * @param center_of_classes
 * @param point
 * @returns {Array}
 */
function getDistanceWithAllCenters(center_of_classes, point){
    var distance = [];
    center_of_classes.forEach(function(element){
        distance.push(getDistance(element, point));
    });
    return distance
}

/**
 * Fonction permettant de déterminer la distance euclidienne entre 2 vecteurs
 * @param v1 vecteur n°1 de taille n
 * @param v2 vecteur n°2 de taille n
 * @returns {number} le distance euclidienne entre ces deux vecteurs
 */
function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        distance += Math.pow((element - v2[index]), 2);
    });
    return Math.sqrt(distance);
}

/**
 *
 * @param vector
 * @returns {Number|number}
 */
function getMinIndex(vector){
    return vector.indexOf(Math.min.apply(null, vector));
}

/**
 *
 * @param class_vector
 * @returns {*[]}
 */
function getBarycenter(class_vector){
    var sum_x = 0;
    var sum_y = 0;
    class_vector.forEach(function(element, index){
        sum_x += element[0];
        sum_y += element[1];
    })
    return [sum_x/class_vector.length, sum_y/class_vector.length];
}

function forAll_getBarycenter(min_index, number_of_classes, data){
    var tmp_classes = [];
    var barycenters = [];
    for (var i = 0; i < number_of_classes; i++) {
        tmp_classes = [];
        min_index.forEach(function(element, index){
            if (element == i) {
                tmp_classes.push(data[index]);
            }
        });
        barycenters.push(getBarycenter(tmp_classes));
    }
    return barycenters;
}