var main = function(){

    /*
     [[1, 2], [4, 5], [7, 8], [1, 5], [5, 9], [6, 7], [5, 5], [8, 8]]
     */

    var number_of_data = 60;
    var data = generateData(number_of_data).map(function(element) {
        return [element[0] * 50, element[1] * 20, element[2]];
    });
    var number_of_classes = 4;

    var barycenters = k_means_algorithm(data, number_of_classes);
    return [data, number_of_classes, barycenters];
}

function k_means_algorithm(data, number_of_classes){
    var classes = [];
    var center_of_classes = [];
    var distance_array = [];
    var min_index = [];

    /*

    Etape 1 : Choisir k individus au hasard comme
    centres initiaux des classes.

    */

    determineCenterOfClassesRandomly(data, center_of_classes, number_of_classes);


    /*

    Etape 2 : On calcule les distances entre chaque
    individu et chaque centre de classe, et on
    affecte l’individu à la classe la plus proche.

      */

    data.forEach(function(element, index){
        distance_array[index] = getDistanceWithAllCenters(center_of_classes, element);
    });


    distance_array.forEach(function(element, index){
        min_index[index] = getMinIndex(element);
    });

    /*

    Etape 3 : On remplace les centres des classes
    par les k centres de gravité des classes définies
    à l’étape 2.

    */


    return forAll_getBarycenter(min_index, number_of_classes, data);

    /*

    Etape 4 : On itère à partir de l’étape 2 jusqu’à
    convergence.

        ==> iterate FUNCTION
    */
}

exports.main = main;


function generateData(number_of_data){
    var data = [];
    for(var i = 0; i < number_of_data; i++){
        data[i] = [Math.floor(Math.random()*10), Math.floor(Math.random()*20)];
    }
    return data;
}


function determineCenterOfClassesRandomly(data, center_of_classes, number_of_classes){
    for(var i = 0; i < number_of_classes; i++){
        center_of_classes[i] = data[Math.floor(Math.random() * data.length)];
    }
}

/**
 *
 * @param center_of_classes
 * @param point
 * @returns {Array}
 */
function getDistanceWithAllCenters(center_of_classes, point){
    var distance = [];
    center_of_classes.forEach(function(element){
        distance.push(getDistance(element, point));
    });
    return distance
}

/**
 * Fonction permettant de déterminer la distance euclidienne entre 2 vecteurs
 * @param v1 vecteur n°1 de taille n
 * @param v2 vecteur n°2 de taille n
 * @returns {number} le distance euclidienne entre ces deux vecteurs
 */
function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        if(index != 2){
            distance += Math.pow((element - v2[index]), 2);
        }
    });
    return Math.sqrt(distance);
}

/**
 *
 * @param vector
 * @returns {Number|number}
 */
function getMinIndex(vector){
    return vector.indexOf(Math.min.apply(null, vector));
}

/**
 *
 * @param class_vector
 * @returns {*[]}
 */
function getBarycenter(class_vector){
    var sum_x = 0;
    var sum_y = 0;
    class_vector.forEach(function(element, index){
        sum_x += element[0];
        sum_y += element[1];
    })
    return [sum_x/class_vector.length, sum_y/class_vector.length];
}

function forAll_getBarycenter(min_index, number_of_classes, data){
    var tmp_classes = [];
    var barycenters = [];
    for (var i = 0; i < number_of_classes; i++) {
        tmp_classes = [];
        min_index.forEach(function(element, index){
            if (element == i) {
                data[index][2] = i;
                tmp_classes.push(data[index]);
            }
        });
        barycenters.push(getBarycenter(tmp_classes));
    }
    return barycenters;
}

var iterate = function(data, number_of_classes, barycenters){
    var distance_array = [];
    var min_index = [];
    data.forEach(function(element, index){
        if(index != 2){
            distance_array[index] = getDistanceWithAllCenters(barycenters, element);
        }
    });
    distance_array.forEach(function(element, index){
        min_index[index] = getMinIndex(element);
    });
    barycenters = forAll_getBarycenter(min_index, number_of_classes, data);
    return [data, number_of_classes, barycenters];
};

exports.iterate = iterate;