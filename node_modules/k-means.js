var main = function(){

    var data = [[1, 2], [4, 5], [7, 8], [1, 5], [5, 9], [6, 7], [5, 5], [8, 8]].map(function(element) {
        return [element[0] * 50, element[1] * 20];
    });
    var number_of_classes = 2;
    k_means_algorithm(data, number_of_classes);
    return data;

}

function k_means_algorithm(data, number_of_classes){
    var classes = [];
    var center_of_classes = [];
    var distance_array = [];

    /*

    Etape 1 : Choisir k individus au hasard comme
    centres initiaux des classes.

    */

    for(var i = 0; i < number_of_classes; i++){
        center_of_classes[i] = data[Math.floor(Math.random()*data.length)];
    }

    console.log(center_of_classes);

    /*

    Etape 2 : On calcule les distances entre chaque
    individu et chaque centre de classe, et on
    affecte l’individu à la classe la plus proche.

      */

    data.forEach(function(element, index){
        //distance_array[index] = [
    });

    /*

    Etape 3 : On remplace les centres des classes
    par les k centres de gravité des classes définies
    à l’étape 2.

    */

    /*

    Etape 4 : On itère à partir de l’étape 2 jusqu’à
    convergence.

    */

}

exports.main = main;


function getDistanceWithClasses(classes){
    var distance = [];
    classes.forEach(function(element){

    });
}


/**
 * Fonction permettant de déterminer la distance euclidienne entre 2 vecteurs
 * @param v1 vecteur n°1 de taille n
 * @param v2 vecteur n°2 de taille n
 * @returns {number} le distance euclidienne entre ces deux vecteurs
 */
function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        distance += Math.pow((element - v2[index]), 2);
    });
    return Math.sqrt(distance);
}