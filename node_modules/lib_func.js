var n_lines = 500;
var n_columns = 500;
var n_classes = 4;
var dependance = 7/10;
var near = 1;

function main(){
    var tab_mu = [];
    var tab_sigma = [];
    var tab_xi = [];
    var tab_y = [];
    var tab_y_13 = [];
    var tab_y_comp = [];

    /* Création du jeu de données */
    createData(tab_mu, tab_sigma, tab_xi, tab_y);


    /**
     * Traitement complètement indépendant
     *
         generateClasses(tab_y);
         classify([100, 10, 8.5, 45, 800, 10, 25, 47, 84, 700], tab_xi, tab_y, 3);
     */


    /**
     *  Traitement des dépendances
     */
    generateClassesDependently(tab_y, tab_y_13);
    for (var i = Math.floor(dependance*n_lines); i < n_lines; i++){
        var vector = tab_xi.map(function(value, index){ return value[i]; });
        tab_y_comp[i - Math.floor(dependance*n_lines)] = classify(vector, tab_xi.slice(0, Math.floor(dependance*n_lines)), tab_y_13, near);
    }
    console.log("Classes attendues : " + tab_y.slice(Math.floor(dependance*n_lines)));
    console.log("Classes calculées : " + tab_y_comp);
    displayErrorRatio(tab_y.slice(Math.floor(dependance*n_lines)), tab_y_comp);
}

exports.main = main();


function createData(tab_mu, tab_sigma, tab_xi, tab_y){

    for(var i = 0; i < n_columns; i++){
        tab_mu[i] = Math.floor(Math.random() * 1000 - 500);
        tab_sigma[i] = Math.floor(Math.abs(tab_mu[i] / 10) + Math.random() * 10);
        tab_xi[i] = [];
        for(var j = 0; j < n_lines; j++){
            tab_xi[i][j] = tab_sigma[i] * generateZ() + tab_mu[i];
        }
    }
}

function generateZ(){
    return Math.floor(Math.sqrt(-2*Math.log(Math.random()))*Math.cos(2*Math.PI*Math.random()));
}

function generateClasses(tab_y){
    for(var i = 0; i < n_lines; i++){
        tab_y[i] = Math.floor(Math.random() * n_classes) + 1;
    }
}

function generateClassesDependently(tab_y, tab_y_13){
    generateClasses(tab_y);
    for(var i = 0; i < Math.floor(dependance*n_lines); i++){
        tab_y_13[i] = tab_y[i];
    }
}


function classify(vector_to_classify, data, classes, k){
    var tab_distance = [];
    var tmp = 0;

    for(var j = 0; j < n_lines; j++){
        var column = data.map(function(value, index){ return value[j]; });
        tab_distance[j] = getDistance(vector_to_classify, column);
    }

    var tab_distance_sorted = tab_distance.sort(function(a,b){return a-b});
    var new_class = getClassMajority(tab_distance, tab_distance_sorted.slice(0, k), classes);
    return new_class;
}

function getClassMajority(tab_distance, tab_distance_sorted, classes){
    var tab = initTab(n_classes);
    tab_distance_sorted.forEach(function(element_sorted, index){
        tab[classes[tab_distance.indexOf(element_sorted)]-1] += 1;
    });
    return tab.indexOf(Math.max.apply(null, tab)) + 1;
}


function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        distance += Math.pow((element - v2[index]), 2);
    });
    return Math.sqrt(distance);
}

function getDistanceManhattan(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        distance += Math.abs(element - v2[index]);
    });
    return distance;
}

function initTab(n){
    var tab = [];
    for(var i = 0; i < n; i++){
        tab[i] = 0;
    }
    return tab;
}

function displayErrorRatio(classes_defined, classes_found){
    var total = 0;
    classes_defined.forEach(function(element, index){
        if (element != classes_found[index]) {
            total += 1;
        }
    });
    console.log("Pourcentage d'erreur : " + (total/classes_defined.length)*100+"%");
}