function createData(){
    var tab_mu = [];
    var tab_sigma = [];
    var tab_xi = [];

    for(var i = 0; i < 10; i++){
        tab_mu[i] = Math.random() * 1000 - 500;
        tab_sigma[i] = Math.abs(tab_mu[i] / 10) + Math.random() * 10;
        tab_xi[i] = [];
        for(var j = 0; j < 1000; j++){
            tab_xi[i][j] = tab_sigma[i] * generateZ() + tab_mu[i];
        }
    }
    var tab_y = generateClasses();
    console.log("tab_mu");
    console.log(tab_mu);
    console.log("tab_sigma");
    console.log(tab_sigma);
    console.log("tab_xi");
    console.log(tab_xi);
    console.log("tab_y");
    console.log(tab_y);
}

function generateZ(){
    return Math.sqrt(-2*Math.log(Math.random()))*Math.cos(2*Math.PI*Math.random());
}

function generateClasses(){
    var tab_y = [];
    for(var i = 0; i < 1000; i++){
        tab_y[i] = Math.floor(Math.random() * 4) + 1;
    }
    return tab_y;
}

exports.createData = createData();

/*
     Règle : Si Xi < ? ... && Xp > ?? alors Y = ?
     Très dépendnant => Règle pour tous les Xi
     Partiellement => Règle pour les 3 premiers Xi
     Totalement indépendant => Random entre tous les Xi
 */

/*
    Algo :
        Calcule la distance entre le vecteur qu'on lui passe et l'ensemble des données
        Récupère les k plus courtes distances
        Affecter au vecteur donné la classe majoritaire dans k plus courtes distances
 */

function classify(vector_to_classify, data, classes, k){
    var tab_distance = [];
    var tmp = 0;

    for(var i = 0; i < 10; i++){
        var column = data.map(function(){ return data[i]; });
        tab_distance[i] = getDistance(vector_to_classify, column);
    }
}

function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        distance += Math.pow((element - v2[index]), 2);
    });
    return distance;
}