var n_lines = 30;
var n_columns = 5;
var n_classes = 4;

function main(){
    var tab_mu = [];
    var tab_sigma = [];
    var tab_xi = [];
    var tab_y = [];
    var tab_y_13 = [];
    var tab_y_comp = [];

    /* Création du jeu de données */
    createData(tab_mu, tab_sigma, tab_xi, tab_y);

    /* Traitement complètement indépendant */
    /*generateClasses(tab_y);
    classify([100, 10, 8.5, 45, 800, 10, 25, 47, 84, 700], tab_xi, tab_y, 3);*/

    /* Traitement partiellement dépendant */
    generateClasses_13(tab_y, tab_y_13);
    console.log("tab_xi :");
    console.log(tab_xi);
    for (var i = Math.floor(2/3*n_lines); i < n_lines; i++){
        console.log("tab_xi.map(function(value, index){ return value[i]; }) : " + tab_xi.map(function(value, index){ return value[i]; }));
        tab_y_comp[i - Math.floor(2/3*n_lines)] = classify(tab_xi.map(function(value, index){ return value[i]; }), tab_xi, tab_y_13, 3);
    }
    console.log("tab_y_13_res : " + tab_y_comp);

}

exports.main = main();


function createData(tab_mu, tab_sigma, tab_xi, tab_y){

    for(var i = 0; i < n_columns; i++){
        tab_mu[i] = Math.floor(Math.random() * 1000 - 500);
        tab_sigma[i] = Math.floor(Math.abs(tab_mu[i] / 10) + Math.random() * 10);
        tab_xi[i] = [];
        for(var j = 0; j < n_lines; j++){
            tab_xi[i][j] = tab_sigma[i] * generateZ() + tab_mu[i];
        }
    }
}

function generateZ(){
    return Math.floor(Math.sqrt(-2*Math.log(Math.random()))*Math.cos(2*Math.PI*Math.random()));
}

function generateClasses(tab_y){
    for(var i = 0; i < n_lines; i++){
        tab_y[i] = Math.floor(Math.random() * n_classes) + 1;
    }
}

function generateClasses_13(tab_y, tab_y_13){
    generateClasses(tab_y);
    for(var i = 0; i < Math.floor(2/3*n_lines); i++){
        tab_y_13[i] = tab_y[i];
    }
}

/*
     Règle : Si Xi < ? ... && Xp > ?? alors Y = ?
     Très dépendnant => Règle pour tous les Xi
     Partiellement => Règle pour les 3 premiers Xi
     Totalement indépendant => Random entre tous les Xi
 */

/*
    Algo :
        Calcule la distance entre le vecteur qu'on lui passe et l'ensemble des données
        Récupère les k plus courtes distances
        Affecter au vecteur donné la classe majoritaire dans k plus courtes distances
 */

function classify(vector_to_classify, data, classes, k){
    var tab_distance = [];
    var tmp = 0;

    for(var j = 0; j < n_lines; j++){
        var column = data.map(function(value, index){ return value[j]; });
        tab_distance[j] = getDistance(vector_to_classify, column);
    }

    var tab_distance_sorted = tab_distance.sort(function(a,b){return a-b});
    var new_class = getClassMajority(tab_distance, tab_distance_sorted.slice(0, k), classes);
    console.log("new_class : "+new_class);
    return new_class;
}

function getClassMajority(tab_distance, tab_distance_sorted, classes){
    var i;
    var tab = initTab(n_classes);
    tab_distance_sorted.forEach(function(element_sorted, index){
        tab[classes[tab_distance.indexOf(element_sorted)]-1] += 1;
    });
    return tab.indexOf(Math.max.apply(null, tab)) + 1;
}



//TODO Faire distance euclidienne et Manhattan !
function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        distance += Math.pow((element - v2[index]), 2);
    });
    return Math.sqrt(distance);
}

function initTab(n){
    var tab = [];
    for(var i = 0; i < n; i++){
        tab[i] = 0;
    }
    return tab;
}


//TODO Analyse d'erreur