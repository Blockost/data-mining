var fs = require('fs');

/* Définition de la fonction principale de l'algo */
var main = function(){

    var n_lines = 150;
    var n_columns = 4;
    var n_classes = 3;
    var cross_validation = 7/8;
    var nearest_numbers = 2; // Prendre un k trop grand revient à prendre la classe ayant le plus gros effectif (ne sert à rien de calculer la distance du coup...)


    /* Variables */
    var tab_x = [];
    var tab_classes = [];

    /* Lecture du jeu de données */
    readData(tab_x, tab_classes);
    console.log("Nearest neighbors using IRIS dataset");
    nearest_neighbors(tab_x, tab_classes, cross_validation, nearest_numbers);


    /////////////////////////////////

    tab_x = [];
    tab_classes = [];
    createRandomData(tab_x, tab_classes, n_lines, n_columns, n_classes);
    console.log("Nearest neighbors using absolutely randomly generated dataset")
    nearest_neighbors(tab_x, tab_classes, cross_validation, nearest_numbers);


    ////////////////////////////////////

    /*
        Create lowdependant dataset
        1/3 : dependant || 2/3 : random
     */

    tab_x = [];
    tab_classes = [];
    createDependantData(tab_x, tab_classes, n_lines/3, n_columns, n_classes);
    createRandomData(tab_x, tab_classes, 2*n_lines/3, n_columns, n_classes);

    console.log("Nearest neighbors using low-dependant generated dataset")
    nearest_neighbors(tab_x, tab_classes, cross_validation, nearest_numbers);


    //////////////////////////////////////////////////////


    /*
        Create high-dependant dataset
        All dependant
     */

    tab_x = [];
    tab_classes = [];
    createDependantData(tab_x, tab_classes, n_lines, n_columns, n_classes);
    console.log("Nearest neighbors using highly-dependant generated dataset")
    nearest_neighbors(tab_x, tab_classes, cross_validation, nearest_numbers);
}

exports.main = main;

/**
 * Procédure de lecture du fichier data.txt
 * @param tab_x Doit être initialisé à vide. Est rempli des valeurs de data.txt
 * @param tab_classes Doit être initialisé à vide. Est rempli des classes de data.txt
 */
function readData(tab_x, tab_classes) {
    var data = fs.readFileSync('data.txt', 'utf8');
    var lines = [];
    lines = data.split("\n");
    lines = lines.map(function(element){
        element = element.split(",");
        element = element.map(function(element_inside){
            element_inside = parseFloat(element_inside);
            return element_inside;
        });
        return element;
    });

    shuffle(lines);

    lines.forEach(function (element) {
        var tab_tmp = [];
        element.forEach(function (element_inside, index) {
            if (index != element.length - 1) {
                tab_tmp.push(element_inside);
            } else {
                tab_classes.push(element_inside);
            }
        });
        tab_x.push(tab_tmp);
    });
}


function shuffle(o){
    for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
    return o;
};

/**
 *
 * @param tab_x
 * @param tab_classes
 * @param n_lines
 * @param n_columns
 */
function createRandomData(tab_x, tab_classes, n_lines, n_columns, n_classes) {
    var mu = Math.random() * 8;
    var sigma = Math.abs(mu / 10) + Math.random() * 10;
    for (var i = 0; i < n_lines; i++) {
        var tab_tmp = [];
        for (var j = 0; j < n_columns; j++) {
            tab_tmp.push(parseFloat(Math.abs(sigma * generateZ() + mu).toFixed(1)));
        }
        tab_x.push(tab_tmp);
        tab_classes.push(Math.floor(Math.random()*n_classes + 1));
    }
}

/**
 *
 * @param tab_x
 * @param tab_classes
 */
function createDependantData(tab_x, tab_classes, n_lines, n_columns, n_classes) {
    var mu = Math.random() * 8;
    var sigma = Math.abs(mu / 10) + Math.random() * 10;
    var tab_tmp = [];
    var tmp_classes = []; // tableau contenant les "classes" de chaque vecteur (non formatté)
    for (var i = 0; i < n_lines; i++) {
        tab_tmp = [];
        for (var j = 0; j < n_columns; j++) {
            tab_tmp.push(parseFloat(Math.abs(sigma * generateZ() + mu).toFixed(1)));
        }
        tab_x.push(tab_tmp);
        tmp_classes.push(
            Math.round(tab_tmp.reduce(
                function(previous, current){
                    return previous + current;
                })));

    }

    // Il ne reste plus qu'à échelonner la classe obtenu entre 1 et n_classes
    formatClass(tab_classes, tmp_classes, n_classes);
}


function formatClass(formated_classes, unformated_classes, n_classes){
    var max = Math.max.apply(null, unformated_classes);
    var min = Math.min.apply(null, unformated_classes);

    if(max - min != 0){
        unformated_classes.forEach(function(element){
            formated_classes.push(Math.round(((element-min)/(max-min))*(n_classes-1))+1);
        });
    }else{
        throw "Range error... ";
    }

}



/**
 * Fonction permettant une variable aléatoire avec une distribution normale standard
 * @returns {number} nombre aléatoire
 */
function generateZ(){
    return Math.sqrt(-2*Math.log(Math.random())) * Math.cos(2*Math.PI*Math.random());
}



function nearest_neighbors(data, classes, cross_validation, nearest_numbers){


    /*
     Découpage du jeu de données en @param cross-validation / 1 - @param cross-validation
     On se sert de @param cross-validation du jeu de données comme learning base
     Le reste représente les vecteur à classer.
     On classe par la méthode des k plus proche voisins (distance entre le vecteur cible et les autres vecteurs)
     On calcule l'erreur engendrée
     */



    var data_sample = buildDataSample(data, cross_validation);
    var data_test = buildDataTest(data, cross_validation);

    var test_classes = classify(data_sample, data_test, classes, nearest_numbers);

    displayErrorRatio(classes.slice(cross_validation * data.length, classes.length+3), test_classes);


}

function buildDataSample(data, cross_validation){
    var data_sample = [];
    for(var i = 0; i < Math.floor(cross_validation * data.length); i++){
        data_sample.push(data[i]);
    }
    return data_sample;
}


function buildDataTest(data, cross_validation){
    var data_test = [];
    for(var i = Math.floor(cross_validation*data.length); i < data.length; i++){
        data_test.push(data[i]);
    }
    return data_test;
}

function classify(data_sample, data_test, classes, nearest_numbers){
    var test_classes = [];;

    /*
        Pour chaque vecteur de @param data_set
            -- Calculer la distance avec l'échantillon
            Choper les k plus proches
            Compter la classe majoritaire
            Lui affecter cette classe
     */


    data_test.forEach(function(vector_test){
        test_classes.push(classifyOneVector(vector_test, data_sample, classes, nearest_numbers));
    });

    return test_classes;

}

function classifyOneVector(vector_to_classify, data_sample, classes, nearest_numbers){
    var distances = [];
    var nearest_classes = [];
    data_sample.forEach(function(vector_sample){
        distances.push(getDistance(vector_to_classify, vector_sample));
    });
    nearest_classes = getNearestNeighborsClasses(distances, nearest_numbers, classes);
    return mode(nearest_classes);
}


function getNearestNeighborsClasses(distances, nearest_numbers, classes){
    var nearest_index = [];
    var nearest_classes = [];
    for(var i = 0; i < nearest_numbers; i++){
        nearest_index[i] = distances.indexOf(Math.min.apply(null, distances));
        distances.splice(nearest_index[i], 1);
    }

    nearest_index.forEach(function(element){
       nearest_classes.push(classes[element]);
    });
    return nearest_classes;
}


function mode(array)
{
    if(array.length == 0)
        return null;
    var modeMap = {};
    var maxEl = array[0], maxCount = 1;
    for(var i = 0; i < array.length; i++)
    {
        var el = array[i];
        if(modeMap[el] == null)
            modeMap[el] = 1;
        else
            modeMap[el]++;
        if(modeMap[el] > maxCount)
        {
            maxEl = el;
            maxCount = modeMap[el];
        }
    }
    return maxEl;
}


/**
 * Fonction permettant de déterminer la distance euclidienne entre 2 vecteurs
 * @param v1 vecteur n°1 de taille n
 * @param v2 vecteur n°2 de taille n
 * @returns {number} le distance euclidienne entre ces deux vecteurs
 */
function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        distance += Math.pow((element - v2[index]), 2);
    });
    return Math.sqrt(distance);
}


/**
 * Fonction permettant de calculer et d'afficher le ratio d'erreur dans la détermination des classes
 * @param classes_defined les classes attendues
 * @param classes_found les classes trouvées
 */
function displayErrorRatio(classes_defined, classes_found){
    var total = 0;
    classes_defined.forEach(function(element, index){
        if (element != classes_found[index]) {
            total += 1;
        }
    });
    console.log(classes_defined);
    console.log(classes_found);
    console.log("Pourcentage d'erreur : " + (total/classes_defined.length)*100+"% \n");
}
