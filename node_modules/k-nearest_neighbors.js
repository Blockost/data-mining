/*
    Variables globales modélisant les paramètres de l'algo
 */
var n_lines = 10;
var n_columns = 4;
var n_classes = 5;
var base_learning_size = 3/4;
var near = 5;

/**
 * Fonction principale du programme
 */
var main = function(){
    var tab_mu = [];
    var tab_sigma = [];
    var tab_xi = [];
    var tab_y = [];
    var tab_y_semi_dependent = [];
    var tab_y_comp = [];

    // Création du jeu de données
    createData(tab_mu, tab_sigma, tab_xi);

    /**
     * Il faut décommenter la méthode que l'on veut utiliser
     */

    //Traitement complètement indépendant
    //generateClasses(tab_y);
    //classify([100, 10, 8.5, 45, 800, 10, 25, 47, 84, 700], tab_xi, tab_y, 3);


    // Traitement des dépendances
    console.log("tab xi");
    console.log(tab_xi);
    console.log("tab_mu : " + tab_mu);
    console.log("tab_sigma : " + tab_sigma);
    console.log("\n");


    generateClassesDependently(tab_xi, tab_mu, tab_sigma, tab_y, tab_y_semi_dependent);
    for (var i = Math.floor(base_learning_size*n_lines); i < n_lines; i++){
        var vector = tab_xi.map(function(value, index){ return value[i]; });
        tab_y_comp[i - Math.floor(base_learning_size*n_lines)] = classify(vector, tab_xi.slice(0, Math.floor(base_learning_size*n_lines)), tab_y_semi_dependent, near);
    }

    console.log("tab y");
    console.log(tab_y);

    console.log("Classes attendues : " + tab_y.slice(Math.floor(base_learning_size*n_lines)));
    console.log("Classes calculées : " + tab_y_comp);
    displayErrorRatio(tab_y.slice(Math.floor(base_learning_size*n_lines)), tab_y_comp);


}

exports.main = main;


/**
 * Fonction permettant de construire le jeu de donnée
 * @param tab_mu vecteur des moyennes
 * @param tab_sigma vecteur des variances
 * @param tab_xi matrice de données
 */
function createData(tab_mu, tab_sigma, tab_xi){

    for(var i = 0; i < n_columns; i++){
        tab_mu[i] = Math.random() * 1000 - 500;
        tab_sigma[i] = Math.abs(tab_mu[i] / 10) + Math.random() * 10;
        tab_xi[i] = [];
        for(var j = 0; j < n_lines; j++){
            tab_xi[i][j] = Math.floor(tab_sigma[i] * generateZ() + tab_mu[i]);
        }
    }
}

/**
 * Fonction permettant une variable aléatoire avec une distribution normal standard
 * @returns {number} nombre aléatoire
 */
function generateZ(){
    return Math.sqrt(-2*Math.log(Math.random()))*Math.cos(2*Math.PI*Math.random());
}

/**
 * Fonction permettant de générer des classes aléatoires comprises entre 1 et n_classes
 * @param tab_y vecteur des classes
 */
function generateClasses(tab_y){
    for(var i = 0; i < n_lines; i++){
        tab_y[i] = Math.floor(Math.random() * n_classes) + 1;
    }
}

/**
 * Fonction permettant de générer les classes 'semi' dépendantes
 * @param tab_xi matrice de données
 * @param tab_mu vecteur des moyennes
 * @param tab_sigma vecteur des variances
 * @param tab_y vecteur des classes
 * @param tab_y_semi_dependent vecteur des classes
 */
function generateClassesDependently(tab_xi, tab_mu, tab_sigma, tab_y, tab_y_semi_dependent){
    /* Generate classes from math formula */
    for(var i = 0; i < n_lines; i++){
        tab_y[i] = 0;
        for(var j = 0; j < n_columns; j++) {
            tab_y[i] += Math.abs((tab_xi[j][i] - tab_mu[j]) / tab_sigma[j]);
            console.log("tab_y[i] : " + tab_y[i]);

        }
        tab_y[i] = Math.floor(tab_y[i]);
    }

    for(var i = 0; i < Math.floor(base_learning_size*n_lines); i++){
        tab_y_semi_dependent[i] = tab_y[i];
    }
}

/**
 * Fonction permettant de déterminer les classes d'un vecteur en fonction du jeu de données
 * @param vector_to_classify le vecteur que l'on cherche à classer
 * @param data le jeu de données
 * @param classes le vecteur de classes déjà trouvées (ou arbritraiment attribuée)
 * @param k le nombre de 'plus proches voisins'
 * @returns {number} la classe (comprise entre 1 et n_classes)
 */
function classify(vector_to_classify, data, classes, k){
    var tab_distance = [];
    var tmp = 0;

    for(var j = 0; j < n_lines; j++){
        var line = data.map(function(value, index){ return value[j]; });
        //console.log(line);
        // TODO vérifier la getDistance si jamais ...
        tab_distance[j] = getDistance(vector_to_classify, line);
    }

    var tab_distance_sorted = tab_distance.sort(function(a,b){return a-b});
    // TODO vérifier les paramètres de getClassMajority
    var new_class = getClassMajority(tab_distance, tab_distance_sorted.slice(0, k), classes);
    return new_class;
}

/**
 * Fonction permettant de déterminer la classe majoritaire en fonction de la distance avec le jeu de données
 * @param tab_distance tableau ayant pour données la distance entre le vecteur et le jeu de données
 * @param tab_distance_sorted tableau des distances trié par ordre croissant
 * @param classes
 * @returns {*}
 */
function getClassMajority(tab_distance, tab_distance_sorted, classes){
    var tab = initTab(n_classes);
    console.log("tab_distance : " + tab_distance);
    console.log("tab_distance_sorted : " + tab_distance_sorted);
    console.log("classes : " + classes);
    tab_distance_sorted.forEach(function(element_sorted, index){
        console.log("---");
        console.log("element_sorted : " + element_sorted);
        console.log("tab_distance.indexOf(element_sorted) : " + tab_distance.indexOf(element_sorted));
        console.log("classes[tab_distance.indexOf(element_sorted)]-1 : " + (classes[tab_distance.indexOf(element_sorted)]-1));
        console.log("tab[classes[tab_distance.indexOf(element_sorted)]-1] : " + tab[classes[tab_distance.indexOf(element_sorted)]-1]);
        tab[classes[tab_distance.indexOf(element_sorted)]-1] += 1;
        console.log("tab : " + tab);
    });
    console.log("\n");
    return tab.indexOf(Math.max.apply(null, tab)) + 1;
}


/**
 * Fonction permettant de déterminer la distance euclidienne entre 2 vecteurs
 * @param v1 vecteur n°1 de taille n
 * @param v2 vecteur n°2 de taille n
 * @returns {number} le distance euclidienne entre ces deux vecteurs
 */
function getDistance(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        distance += Math.pow((element - v2[index]), 2);
    });
    return Math.sqrt(distance);
}

/**
 * Fonction permettant de déterminer la distance de Manhanttan entre 2 vecteurs
 * @param v1 vecteur n°1 de taille n
 * @param v2 vecteur n°2 de taille n
 * @returns {number} le distance de Manhanttan entre ces deux vecteurs
 */
function getDistanceManhattan(v1, v2){
    var distance = 0;
    v1.forEach(function(element, index){
        distance += Math.abs(element - v2[index]);
    });
    return distance;
}

/**
 * Fonction permettant d'initialiser simplement un tableau avec des zeros
 * @param n nombre de 0 à insérer dans le tableau
 * @returns {Array} le tableau initialisé avec n zeros
 */
function initTab(n){
    var tab = [];
    for(var i = 0; i < n; i++){
        tab[i] = 0;
    }
    return tab;
}

/**
 * Fonction permettant de calculer et d'afficher le ratio d'erreur dans la détermination des classes
 * @param classes_defined les classes attendues
 * @param classes_found les classes trouvées
 */
function displayErrorRatio(classes_defined, classes_found){
    var total = 0;
    classes_defined.forEach(function(element, index){
        if (element != classes_found[index]) {
            total += 1;
        }
    });
    console.log("Pourcentage d'erreur : " + (total/classes_defined.length)*100+"%");
}